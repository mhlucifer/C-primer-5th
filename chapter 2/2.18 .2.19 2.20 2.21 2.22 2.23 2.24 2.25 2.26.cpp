# include<iostream>
int main()
{
	int* p = 0;
	//更改指针的值  
	int a = 0;
	int* p1 = &a;
	p = p1;//改变指针的值
	*p = 12;//改变指针所指的对象值
	//2.19指针和引用的区别在于指针本质上是对象，引用不是，另外引用必须初始化绑定对象，指针不用
	//2.20 42*42
	//2.21 a违法，不能把两个类型不同的指针赋值，b把变量赋给指针
	//2.22 判断p是不是空指针，判断所指对象是否为0
	//2.23不能，因为通常不能直接判断它是否指向一个合法的对象。这是因为指针只是存储内存地址的变量，而这个地址可能指向一个有效对象、无效对象、已删除对象或未分配的内存空间。尝试访问无效指针通常会导致未定义行为，如程序崩溃
	//2.24 void*可以指向任何类型，但不能查看，而lp是用指针指向不同类型的变量

	//一般来说有多个声明符，可以从右向左开始读，离变量越近的对它的影响越大

	//2.25 ip是一个指针类型，i是int类型，r是一个引用，ip值未知，i看区域，函数内部未知，函数外为0，引用值等于i，（b）i
	//是int类型，ip是指针类型等于0，（c）指针类型 ip ip2是int类型

	//const int i = get_size()是运行时初始化，而const int i = 1是编译时初始化


	//基本类型
	/*对于基本类型如int、double等，赋值操作通常是深拷贝，即将一个变量的值复制到另一个变量，两个变量之后不会相互影响。

	类对象
	对于类对象，赋值操作的行为取决于该类是否重载了赋值操作符（operator = ）。如果没有重载赋值操作符，编译器会提供一个默认的赋值操作符，这个默认的赋值操作符执行逐成员的浅拷贝。如果类包含指针成员，并且指针成员指向动态分配的内存，则需要重载赋值操作符以执行深拷贝，以避免两个对象共享相同的内存。*/


	//const默认只在一个文件中有效，extern关键字的作用是当有好多个文件时，只需要声明一个const这样都有效
	// 不过要注意，extern 只是对变量的声明，并不会分配存储空间。存储空间是在变量定义时分配的。而且，extern const 在其他文件中声明时不需要初始化，因为它已经在定义处初始化了。
	//2.26（a）错误 必须初始化 （b）正确 （c）正确 （d）前面对，后面错

	//常量引用（这个称呼并不合理，应该是对const的引用）一般来说引用也是常量

	//常量引用允许在初始化时等于非常量

	
}